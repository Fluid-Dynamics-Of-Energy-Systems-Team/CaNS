module mod_rk
  use mod_param, only: is_forced, velf, ktot, imax, jmax
  use mod_debug, only: chkmean
  use mod_mom  , only: momxad,momyad,momzad,momxp,momyp,momzp
  use mod_momd , only: momxpd,momypd,momzpd,momxa,momya,momza
  use mod_moms , only: momsad
  use cudafor
  use mod_common_cuda, only: stream3, stream4, stream5
  implicit none
  private
  public rk,rk_id
  contains
  subroutine rk(rkpar,n,dli,dzci,dzfi,dzflzi,dzclzi,visc,dt,l,u,v,w,p,dudtrko,dvdtrko,dwdtrko,tauxo,tauyo,tauzo,up,vp,wp,f)
    !
    ! low-storage 3rd-order Runge-Kutta scheme 
    ! for time integration of the momentum equations.
    !
    implicit none
    real(8), intent(in), dimension(2) :: rkpar
    integer, intent(in), dimension(3) :: n
    real(8), intent(in) :: visc,dt
    real(8), intent(in   ), dimension(3) :: dli,l 
    real(8), intent(in   ), dimension(0:) :: dzci,dzfi
    real(8), intent(in   ), dimension(0:) :: dzflzi
    real(8), dimension(0:ktot+1), device :: dzci_d,dzfi_d
    real(8), dimension(0:ktot+1), device :: dzflzi_d
    real(8), intent(in   ), dimension(0:) :: dzclzi
    real(8), intent(in   ), dimension(0:,0:,0:) :: p
    real(8), intent(in), allocatable :: u(:,:,:), v(:,:,:), w(:,:,:)
    real(8), device, dimension(0:imax+1,0:jmax+1,0:ktot+1) :: u_d, v_d, w_d 
    real(8), intent(inout), dimension(:,:,:) :: dudtrko,dvdtrko,dwdtrko
    real(8), dimension(imax,jmax,ktot), device :: dudtrko_d,dvdtrko_d,dwdtrko_d 
    real(8), intent(inout), dimension(3) :: tauxo,tauyo,tauzo
    real(8), intent(out), dimension(0:imax+1,0:jmax+1,0:ktot+1) :: up,vp,wp
    real(8), dimension(0:imax+1,0:jmax+1,0:ktot+1), device :: up_d, vp_d, wp_d
    real(8), intent(out), dimension(3) :: f
    real(8), dimension(imax,jmax,ktot) :: dudtrk, dvdtrk, dwdtrk
    real(8), dimension(imax,jmax,ktot), device :: dudtrk_d, dvdtrk_d, dwdtrk_d
    !real(8) :: factor1,factor2,factor12
    real(8) :: factor1,factor2
    real(8) :: factor12
    real(8), dimension(3) :: tauy,tauz
    real(8), dimension(3) :: taux
    real(8) :: mean
    integer :: i,j,k
    integer :: istat
    integer :: size_uvw   
    !
    factor1 = rkpar(1)*dt
    factor2 = rkpar(2)*dt
    factor12 = factor1 + factor2
    !
    
    !istat = cudaStreamCreate(stream3)
    !istat = cudaStreamCreate(stream4)
    !istat = cudaStreamCreate(stream5)
    !size_uvw = (imax+1) * (jmax+1) * (ktot+1) * 8
    u_d = u
    !istat = cudaMemcpyAsync(u,u_d,size_uvw, stream3)
    v_d = v
    !istat = cudaMemcpyAsync(v,v_d,size_uvw, stream4)
    w_d = w
    !istat = cudaMemcpyAsync(w,w_d,size_uvw, stream5)

    dzci_d = dzci
    dzfi_d = dzfi
    dzflzi_d =  dzflzi

    dudtrko_d = dudtrko
    dvdtrko_d =	dvdtrko
    dwdtrko_d =	dwdtrko 

    call momxp(n(1),n(2),n(3),dli(1),p,dudtrk)
    dudtrk_d  = dudtrk
    call momyp(n(1),n(2),n(3),dli(2),p,dvdtrk)
    dvdtrk_d = dvdtrk
    call momzp(n(1),n(2),n(3),dzci  ,p,dwdtrk)
    dwdtrk_d = dwdtrk
   
    !print *, 'BEFORE Cuf Kernel'
    !acc data copyin(u(0:imax+1,0:jmax+1,0:ktot+1),v(0:imax+1,0:jmax+1,0:ktot+1),w(0:imax+1,0:jmax+1,0:ktot+1),dudtrk(imax,jmax,ktot), dvdtrk(imax,jmax,ktot), dwdtrk(imax,jmax,ktot))   
    !$cuf kernel do(3) <<<*,*>>>
    do k=1,ktot
      do j=1,jmax
        do i=1,imax
          up_d(i,j,k) = u_d(i,j,k) + factor12*dudtrk_d(i,j,k)
          vp_d(i,j,k) = v_d(i,j,k) + factor12*dvdtrk_d(i,j,k)
          wp_d(i,j,k) = w_d(i,j,k) + factor12*dwdtrk_d(i,j,k)
        enddo
      enddo
    enddo
    !end acc data
    !print *, 'AFTER Cuf Kernel'

    !up = up_d
    !vp = vp_d 
    !wp = wp_d

    call momxad(n(1),n(2),n(3),dli(1),dli(2),dli(3),dzci_d,dzfi_d,dzflzi_d,visc,u_d,v_d,w_d,dudtrk_d,taux)
    call momyad(n(1),n(2),n(3),dli(1),dli(2),dli(3),dzci_d,dzfi_d,dzflzi_d,visc,u_d,v_d,w_d,dvdtrk_d,tauy)
    call momzad(n(1),n(2),n(3),dli(1),dli(2),dli(3),dzci_d,dzfi_d,dzflzi_d,visc,u_d,v_d,w_d,dwdtrk_d,tauz)

    f(1) = (factor1*sum(taux(:)/l(:)) + factor2*sum(tauxo(:)/l(:)))
    f(2) = (factor1*sum(tauy(:)/l(:)) + factor2*sum(tauyo(:)/l(:)))
    f(3) = (factor1*sum(tauz(:)/l(:)) + factor2*sum(tauzo(:)/l(:)))
    tauxo(:) = taux(:)
    tauyo(:) = tauy(:)
    tauzo(:) = tauz(:)
    
    !OMP PARALLEL DO DEFAULT(none) &
    !OMP PRIVATE(i,j,k) &
    !OMP SHARED(n,factor1,factor2,up,vp,wp,dudtrk,dvdtrk,dwdtrk,dudtrko,dvdtrko,dwdtrko)
    !$cuf kernel do(3) <<<*,*>>>
    do k=1,ktot
      do j=1,jmax
        do i=1,imax
          ! could be split in two loops, because factor2=0 for istep=1, but like this reads nicer
          up_d(i,j,k) = up_d(i,j,k) + factor1*dudtrk_d(i,j,k) + factor2*dudtrko_d(i,j,k)
          vp_d(i,j,k) = vp_d(i,j,k) + factor1*dvdtrk_d(i,j,k) + factor2*dvdtrko_d(i,j,k)
          wp_d(i,j,k) = wp_d(i,j,k) + factor1*dwdtrk_d(i,j,k) + factor2*dwdtrko_d(i,j,k)
          !dudtrk_d(i,j,k) = dudtrk(i,j,k)
          !dvdtrk_d(i,j,k) = dvdtrk(i,j,k)
          !dwdtrk_d(i,j,k) = dwdtrk(i,j,k)
        enddo
      enddo
    enddo
    !OMP END PARALLEL DO
    istat = cudaDeviceSynchronize()
    
    ! TODO, move before kernel
    dudtrko = dudtrk_d
    dvdtrko = dvdtrk_d  
    dwdtrko = dwdtrk_d
    
    up = up_d
    vp = vp_d
    wp = wp_d
    !
    ! bulk velocity forcing
    !
    f(:) = 0.d0
    if(is_forced(1)) then
      call chkmean(n,dzflzi,up,mean)
      f(1) = velf(1) - mean
    endif
    if(is_forced(2)) then
      call chkmean(n,dzflzi,vp,mean)
      f(2) = velf(2) - mean
    endif
    if(is_forced(3)) then
      call chkmean(n,dzclzi,wp,mean)
      f(3) = velf(3) - mean
    endif
    return
  end subroutine rk
  subroutine rk_id(rkpar,n,dli,dzci,dzfi,dzflzi,dzclzi,visc,dt,l,u,v,w,p,dudtrko,dvdtrko,dwdtrko,tauxo,tauyo,tauzo,up,vp,wp,f)
    !
    ! low-storage 3rd-order Runge-Kutta scheme 
    ! for time integration of the momentum equations with implicit diffusion.
    !
    implicit none
    real(8), intent(in), dimension(2) :: rkpar
    integer, intent(in), dimension(3) :: n
    real(8), intent(in) :: visc,dt
    real(8), intent(in   ), dimension(3) :: dli,l 
    real(8), intent(in   ), dimension(0:) :: dzci,dzfi,dzflzi,dzclzi
    real(8), intent(in   ), dimension(0:,0:,0:) :: u ,v ,w,p
    real(8), intent(inout), dimension(:,:,:) :: dudtrko,dvdtrko,dwdtrko
    real(8), intent(inout), dimension(3) :: tauxo,tauyo,tauzo
    real(8), intent(out), dimension(0:,0:,0:) :: up,vp,wp
    real(8), intent(out), dimension(3) :: f
    real(8),              dimension(n(1),n(2),n(3)) ::          dudtrk, dvdtrk, dwdtrk
    real(8),              dimension(n(1),n(2),n(3)) ::          dudtrkd, dvdtrkd, dwdtrkd
    real(8) :: factor1,factor2,factor12
    real(8), dimension(3) :: taux,tauy,tauz
    integer :: i,j,k
    real(8) :: mean
    !
    factor1 = rkpar(1)*dt
    factor2 = rkpar(2)*dt
    factor12 = factor1 + factor2
    !
    call momxpd(n(1),n(2),n(3),dli(1),dli(2),dzci,dzfi,dzflzi,visc,p,u,dudtrk,dudtrkd,taux)
    call momypd(n(1),n(2),n(3),dli(2),dli(2),dzci,dzfi,dzflzi,visc,p,v,dvdtrk,dvdtrkd,tauy)
    call momzpd(n(1),n(2),n(3),dli(1),dli(2),dzci,dzfi,dzflzi,visc,p,w,dwdtrk,dwdtrkd,tauz)
    f(1) = factor12*sum(taux(:)/l(:))
    f(2) = factor12*sum(tauy(:)/l(:))
    f(3) = factor12*sum(tauz(:)/l(:))
    ! alternatively, calculate force from the mean velocity directly
    !$OMP PARALLEL DO DEFAULT(none) &
    !$OMP PRIVATE(i,j,k) &
    !$OMP SHARED(n,factor12,u,v,w,up,vp,wp,dudtrk,dvdtrk,dwdtrk)
    do k=1,n(3)
      do j=1,n(2)
        do i=1,n(1)
          up(i,j,k) = u(i,j,k) + factor12*dudtrk(i,j,k)
          vp(i,j,k) = v(i,j,k) + factor12*dvdtrk(i,j,k)
          wp(i,j,k) = w(i,j,k) + factor12*dwdtrk(i,j,k)
        enddo
      enddo
    enddo
    !$OMP END PARALLEL DO
    call momxa(n(1),n(2),n(3),dli(1),dli(2),dzci,dzfi,u,v,w,dudtrk)
    call momya(n(1),n(2),n(3),dli(1),dli(2),dzci,dzfi,u,v,w,dvdtrk)
    call momza(n(1),n(2),n(3),dli(1),dli(2),dzci,dzfi,u,v,w,dwdtrk)
    !$OMP PARALLEL DO DEFAULT(none) &
    !$OMP PRIVATE(i,j,k) &
    !$OMP SHARED(n,factor1,factor2,up,vp,wp,dudtrk,dvdtrk,dwdtrk,dudtrko,dvdtrko,dwdtrko)
    do k=1,n(3)
      do j=1,n(2)
        do i=1,n(1)
          ! could be split in two loops, because factor2=0 for istep=1, but like this reads nicer
          up(i,j,k) = up(i,j,k) + factor1*dudtrk(i,j,k) + factor2*dudtrko(i,j,k)
          vp(i,j,k) = vp(i,j,k) + factor1*dvdtrk(i,j,k) + factor2*dvdtrko(i,j,k)
          wp(i,j,k) = wp(i,j,k) + factor1*dwdtrk(i,j,k) + factor2*dwdtrko(i,j,k)
          dudtrko(i,j,k) = dudtrk(i,j,k)
          dvdtrko(i,j,k) = dvdtrk(i,j,k)
          dwdtrko(i,j,k) = dwdtrk(i,j,k)
        enddo
      enddo
    enddo
    !$OMP END PARALLEL DO
    !
    ! bulk velocity forcing
    !
    f(:) = 0.d0
    if(is_forced(1)) then
      call chkmean(n,dzflzi,up,mean)
      f(1) = velf(1) - mean
    endif
    if(is_forced(2)) then
      call chkmean(n,dzflzi,vp,mean)
      f(2) = velf(2) - mean
    endif
    if(is_forced(3)) then
      call chkmean(n,dzclzi,wp,mean)
      f(3) = velf(3) - mean
    endif
    !
    ! compute rhs of helmholtz equation
    !
    !$OMP PARALLEL DO DEFAULT(none) &
    !$OMP PRIVATE(i,j,k) &
    !$OMP SHARED(n,factor12,factor2,visc,up,vp,wp,dudtrkd,dvdtrkd,dwdtrkd)
    do k=1,n(3)
      do j=1,n(2)
        do i=1,n(1)
          up(i,j,k) = up(i,j,k) - .5d0*factor12*dudtrkd(i,j,k)
          vp(i,j,k) = vp(i,j,k) - .5d0*factor12*dvdtrkd(i,j,k)
          wp(i,j,k) = wp(i,j,k) - .5d0*factor12*dwdtrkd(i,j,k)
        enddo
      enddo
    enddo
    !$OMP END PARALLEL DO
    return
  end subroutine rk_id
  subroutine rk_scal(rkpar,n,dli,dzci,dzfi,dzflzi,dzclzi,visc,dt,u,v,w,dsdtrko,s)
    !
    ! low-storage 3rd-order Runge-Kutta scheme 
    ! for time integration of the scalar field.
    !
    implicit none
    real(8), intent(in), dimension(2) :: rkpar
    integer, intent(in), dimension(3) :: n
    real(8), intent(in) :: visc,dt
    real(8), intent(in   ), dimension(3) :: dli
    real(8), intent(in   ), dimension(0:) :: dzci,dzfi,dzflzi,dzclzi
    real(8), intent(in   ), dimension(0:,0:,0:) :: u,v,w
    real(8), intent(inout), dimension(:,:,:) :: dsdtrko
    real(8), intent(inout), dimension(0:,0:,0:) :: s
    real(8),              dimension(n(1),n(2),n(3)) :: dsdtrk
    real(8) :: factor1,factor2,factor12
    integer :: i,j,k
    !
    factor1 = rkpar(1)*dt
    factor2 = rkpar(2)*dt
    factor12 = factor1 + factor2
    call momsad(n(1),n(2),n(3),dli(1),dli(2),dli(3),dzci,dzfi,dzflzi,visc,u,v,w,s,dsdtrk)
    !$OMP PARALLEL DO DEFAULT(none) &
    !$OMP PRIVATE(i,j,k) &
    !$OMP SHARED(n,factor1,factor2,s,dsdtrk,dsdtrko)
    do k=1,n(3)
      do j=1,n(2)
        do i=1,n(1)
          s(i,j,k) = s(i,j,k) + factor1*dsdtrk(i,j,k) + factor2*dsdtrko(i,j,k)
          dsdtrko(i,j,k) = dsdtrk(i,j,k)
        enddo
      enddo
    enddo
    !$OMP END PARALLEL DO
    return
  end subroutine rk_scal
end module mod_rk
